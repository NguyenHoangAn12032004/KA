import { Router } from 'express';
import { prisma } from '../utils/database';
import { authenticateToken } from '../middleware/auth';

// Create and export the router
const router = Router();
export default router;

// POST ƒë·ªÉ c·∫≠p nh·∫≠t profile (thay th·∫ø cho PUT ƒë·ªÉ tr√°nh v·∫•n ƒë·ªÅ CORS)
router.post('/update-profile', authenticateToken, async (req, res) => {
  try {
    const userId = (req as any).user?.id;
    if (!userId) {
      return res.status(401).json({ success: false, message: 'User not authenticated' });
    }
    
    // Log th√¥ng tin chi ti·∫øt
    console.log('üîÑ Processing profile update for user:', userId);
    console.log('üìù Request body:', JSON.stringify(req.body, null, 2));
    console.log('üìä Received profile_completion value:', req.body.profile_completion);
    
    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: { studentProfile: true }
    });
    
    // Log th√¥ng tin user
    console.log('üë§ User found:', user ? 'Yes' : 'No');
    console.log('üë§ User role:', user?.role);
    console.log('üë§ Has student profile:', !!user?.studentProfile);
    console.log('üë§ Current profile_completion in DB:', user?.studentProfile?.profile_completion);
    
    if (!user) {
      return res.status(404).json({ success: false, message: 'User not found' });
    }
    
    if (user.role !== 'STUDENT') {
      console.log('‚ùå User is not a student. Role:', user.role);
      return res.status(400).json({ success: false, message: 'Profile update not supported for this user type' });
    }
    
    const profileData = req.body;
    console.log('üîÑ Backend: Updating student profile for user:', userId);
    let updatedProfile;
    
    try {
      if (user.studentProfile) {
        console.log('üîÑ Updating existing profile');
        
        // ƒê·∫£m b·∫£o profile_completion ƒë∆∞·ª£c l∆∞u ƒë√∫ng
        const profileCompletionValue = profileData.profile_completion !== undefined 
          ? parseInt(profileData.profile_completion.toString()) 
          : user.studentProfile.profile_completion || 0;
          
        console.log('üìä Using profile_completion value for update:', profileCompletionValue);
        console.log('üìä Type of profile_completion:', typeof profileCompletionValue);
        
        // C·∫≠p nh·∫≠t profile v·ªõi SQL tr·ª±c ti·∫øp ƒë·ªÉ ƒë·∫£m b·∫£o l∆∞u ƒë√∫ng gi√° tr·ªã
        try {
          // C·∫≠p nh·∫≠t profile
          updatedProfile = await prisma.studentProfile.update({
            where: { userId },
            data: {
              firstName: profileData.firstName,
              lastName: profileData.lastName,
              phone: profileData.phone,
              portfolio: profileData.portfolio,
              linkedin: profileData.linkedin,
              github: profileData.github,
              experience: profileData.summary,
              skills: profileData.skills || [],
              // C·∫≠p nh·∫≠t profile_completion t·ª´ frontend
              profile_completion: profileCompletionValue,
              updatedAt: new Date()
            }
          });
          
          // Ki·ªÉm tra xem profile_completion ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t ch∆∞a
          console.log('üìä Updated profile_completion in DB:', updatedProfile.profile_completion);
          
          // N·∫øu kh√¥ng ƒë∆∞·ª£c c·∫≠p nh·∫≠t, th·ª≠ c·∫≠p nh·∫≠t tr·ª±c ti·∫øp b·∫±ng SQL
          if (updatedProfile.profile_completion !== profileCompletionValue) {
            console.log('‚ö†Ô∏è profile_completion not updated correctly, trying with raw SQL');
            
            await prisma.$executeRaw`
              UPDATE "public"."student_profiles" 
              SET "profile_completion" = ${profileCompletionValue}
              WHERE "userId" = ${userId}
            `;
            
            // Ki·ªÉm tra l·∫°i sau khi c·∫≠p nh·∫≠t b·∫±ng SQL
            const checkProfile = await prisma.studentProfile.findUnique({
              where: { userId }
            });
            
            console.log('üìä profile_completion after SQL update:', checkProfile?.profile_completion);
            
            if (checkProfile) {
              updatedProfile = checkProfile;
            }
          }
          
          console.log('‚úÖ Profile updated successfully');
        } catch (err) {
          console.error('‚ùå Error updating profile:', err);
          throw err;
        }
      } else {
        console.log('üÜï Creating new profile');
        
        // T·∫°o profile m·ªõi
        updatedProfile = await prisma.studentProfile.create({
          data: {
            userId,
            firstName: profileData.firstName || '',
            lastName: profileData.lastName || '',
            phone: profileData.phone,
            portfolio: profileData.portfolio,
            linkedin: profileData.linkedin,
            github: profileData.github,
            experience: profileData.summary,
            skills: profileData.skills || [],
            // C·∫≠p nh·∫≠t profile_completion t·ª´ frontend
            profile_completion: profileData.profile_completion || 0,
            createdAt: new Date(),
            updatedAt: new Date()
          }
        });
        
        console.log('‚úÖ Profile created successfully');
      }
    } catch (err) {
      console.error('‚ùå Error updating profile:', err);
      return res.status(400).json({ 
        success: false, 
        message: 'Error updating profile: ' + (err as Error).message 
      });
    }
    
    // C·∫≠p nh·∫≠t education
    try {
      if (profileData.education) {
        console.log('üîÑ Updating education data:', profileData.education);
        
        // X√≥a d·ªØ li·ªáu education c≈©
        await prisma.studentEducation.deleteMany({ 
          where: { studentId: updatedProfile.id } 
        });
        
        // Th√™m d·ªØ li·ªáu education m·ªõi n·∫øu c√≥
        if (profileData.education.length > 0) {
          await prisma.studentEducation.createMany({
            data: profileData.education.map((edu: any) => ({
              studentId: updatedProfile.id,
              institution: edu.institution || '',
              degree: edu.degree || '',
              fieldOfStudy: edu.fieldOfStudy || '',
              startDate: new Date(edu.startDate),
              endDate: edu.endDate ? new Date(edu.endDate) : null,
              current: edu.current || false,
              gpa: edu.gpa,
              achievements: edu.achievements
            }))
          });
        }
        
        console.log('‚úÖ Education data updated successfully');
      }
    } catch (err) {
      console.error('‚ùå Error updating education:', err);
      return res.status(400).json({ 
        success: false, 
        message: 'Error updating education: ' + (err as Error).message 
      });
    }
    
    // C·∫≠p nh·∫≠t projects
    try {
      if (profileData.projects) {
        console.log('üîÑ Updating projects data:', profileData.projects);
        
        // X√≥a d·ªØ li·ªáu projects c≈©
        await prisma.studentProject.deleteMany({ 
          where: { studentId: updatedProfile.id } 
        });
        
        // Th√™m d·ªØ li·ªáu projects m·ªõi n·∫øu c√≥
        if (profileData.projects.length > 0) {
          await prisma.studentProject.createMany({
            data: profileData.projects.map((proj: any) => ({
              studentId: updatedProfile.id,
              title: proj.title || '',
              description: proj.description || '',
              technologies: proj.technologies || [],
              startDate: new Date(proj.startDate),
              endDate: proj.endDate ? new Date(proj.endDate) : null,
              current: proj.current || false,
              githubUrl: proj.githubUrl || '',
              liveUrl: proj.liveUrl || '',
              imageUrl: proj.imageUrl || ''
            }))
          });
        }
        
        console.log('‚úÖ Projects data updated successfully');
      }
    } catch (err) {
      console.error('‚ùå Error updating projects:', err);
      return res.status(400).json({ 
        success: false, 
        message: 'Error updating projects: ' + (err as Error).message 
      });
    }
    
    // C·∫≠p nh·∫≠t workExperiences
    try {
      if (profileData.workExperiences) {
        console.log('üîÑ Updating work experiences data:', profileData.workExperiences);
        
        // X√≥a d·ªØ li·ªáu workExperiences c≈©
        await prisma.studentExperience.deleteMany({ 
          where: { studentId: updatedProfile.id } 
        });
        
        // Th√™m d·ªØ li·ªáu workExperiences m·ªõi n·∫øu c√≥
        if (profileData.workExperiences.length > 0) {
          try {
            await prisma.studentExperience.createMany({
              data: profileData.workExperiences.map((exp: any) => {
                // X·ª≠ l√Ω achievements - chuy·ªÉn ƒë·ªïi t·ª´ string sang m·∫£ng string n·∫øu c·∫ßn
                let achievements: string[] = [];
                if (exp.achievements) {
                  if (typeof exp.achievements === 'string') {
                    // N·∫øu l√† string, t√°ch th√†nh m·∫£ng theo d√≤ng m·ªõi
                    achievements = exp.achievements.split('\n').filter((item: string) => item.trim() !== '');
                  } else if (Array.isArray(exp.achievements)) {
                    // N·∫øu ƒë√£ l√† m·∫£ng, s·ª≠ d·ª•ng tr·ª±c ti·∫øp
                    achievements = exp.achievements;
                  }
                }
                
                // Ki·ªÉm tra v√† ƒë·∫£m b·∫£o c√°c tr∆∞·ªùng ng√†y th√°ng h·ª£p l·ªá
                let startDate = new Date();
                try {
                  startDate = exp.startDate ? new Date(exp.startDate) : new Date();
                } catch (err) {
                  console.error('‚ùå Invalid startDate format:', exp.startDate);
                }
                
                let endDate = null;
                try {
                  endDate = exp.endDate && !exp.current ? new Date(exp.endDate) : null;
                } catch (err) {
                  console.error('‚ùå Invalid endDate format:', exp.endDate);
                }
                
                // Log chi ti·∫øt t·ª´ng m·ª•c work experience
                console.log(`üìù Processing work experience: ${exp.company} - ${exp.position}`);
                console.log(`üìÖ Dates: ${startDate} to ${endDate}, current: ${exp.current}`);
                
                return {
                  studentId: updatedProfile.id,
                  company: exp.company || '',
                  position: exp.position || '',
                  description: exp.description || '',
                  startDate: startDate,
                  endDate: endDate,
                  current: exp.current || false,
                  skills: exp.skills || [],
                  achievements: achievements
                };
              })
            });
            console.log('‚úÖ Work experiences created successfully');
          } catch (expError) {
            console.error('‚ùå Error creating work experiences:', expError);
            console.error('‚ùå Error details:', (expError as Error).message);
            throw expError;
          }
        }
        
        console.log('‚úÖ Work experiences data updated successfully');
      }
    } catch (err) {
      console.error('‚ùå Error updating work experiences:', err);
      return res.status(400).json({ 
        success: false, 
        message: 'Error updating work experiences: ' + (err as Error).message 
      });
    }
    
    // C·∫≠p nh·∫≠t certifications
    try {
      if (profileData.certifications) {
        console.log('üîÑ Updating certifications data:', profileData.certifications);
        
        // X√≥a d·ªØ li·ªáu certifications c≈©
        await prisma.studentCertification.deleteMany({ 
          where: { studentId: updatedProfile.id } 
        });
        
        // Th√™m d·ªØ li·ªáu certifications m·ªõi n·∫øu c√≥
        if (profileData.certifications.length > 0) {
          try {
            await prisma.studentCertification.createMany({
              data: profileData.certifications.map((cert: any) => {
                // Ki·ªÉm tra v√† x·ª≠ l√Ω nƒÉm
                let issueDate = new Date();
                try {
                  if (cert.year) {
                    // N·∫øu ch·ªâ c√≥ nƒÉm, t·∫°o ng√†y 1/1/nƒÉm ƒë√≥
                    issueDate = new Date(`${cert.year}-01-01`);
                  } else if (cert.issueDate) {
                    // N·∫øu c√≥ ng√†y ƒë·∫ßy ƒë·ªß, s·ª≠ d·ª•ng tr·ª±c ti·∫øp
                    issueDate = new Date(cert.issueDate);
                  }
                } catch (err) {
                  console.error('‚ùå Invalid date format:', cert.year || cert.issueDate);
                }
                
                // Log chi ti·∫øt t·ª´ng ch·ª©ng ch·ªâ
                console.log(`üìù Processing certification: ${cert.name} from ${cert.issuer}`);
                console.log(`üìÖ Issue date: ${issueDate}`);
                
                return {
                  studentId: updatedProfile.id,
                  name: cert.name || '',
                  issuer: cert.issuer || '',
                  issueDate: issueDate,
                  expiryDate: null,
                  credentialId: cert.credentialId || '',
                  credentialUrl: cert.credentialUrl || ''
                };
              })
            });
            console.log('‚úÖ Certifications created successfully');
          } catch (certError) {
            console.error('‚ùå Error creating certifications:', certError);
            console.error('‚ùå Error details:', (certError as Error).message);
            throw certError;
          }
        }
        
        console.log('‚úÖ Certifications data updated successfully');
      }
    } catch (err) {
      console.error('‚ùå Error updating certifications:', err);
      return res.status(400).json({ 
        success: false, 
        message: 'Error updating certifications: ' + (err as Error).message 
      });
    }
    
    // L·∫•y d·ªØ li·ªáu profile ƒë·∫ßy ƒë·ªß sau khi c·∫≠p nh·∫≠t
    const completeProfile = await prisma.studentProfile.findUnique({
      where: { userId },
      include: {
        educations: true,
        workExperiences: true,
        projects: true,
        languages: true,
        certifications: true
      }
    });
    
    // Chu·∫©n b·ªã d·ªØ li·ªáu tr·∫£ v·ªÅ
    const responseData = {
      id: completeProfile!.id,
      firstName: completeProfile!.firstName,
      lastName: completeProfile!.lastName,
      email: user.email,
      phone: completeProfile!.phone,
      dateOfBirth: completeProfile!.dateOfBirth,
      university: completeProfile!.university,
      major: completeProfile!.major,
      graduationYear: completeProfile!.graduationYear,
      gpa: completeProfile!.gpa,
      skills: completeProfile!.skills || [],
      portfolio: completeProfile!.portfolio,
      linkedin: completeProfile!.linkedin,
      github: completeProfile!.github,
      resume: completeProfile!.resume,
      avatar: completeProfile!.avatar,
      summary: completeProfile!.experience,
      education: completeProfile!.educations.map(edu => ({
        id: edu.id,
        institution: edu.institution,
        degree: edu.degree,
        fieldOfStudy: edu.fieldOfStudy,
        startDate: edu.startDate.toISOString().split('T')[0],
        endDate: edu.endDate ? edu.endDate.toISOString().split('T')[0] : '',
        current: edu.current,
        gpa: edu.gpa,
        achievements: edu.achievements
      })),
      workExperience: completeProfile!.workExperiences.map(exp => ({
        id: exp.id,
        company: exp.company,
        position: exp.position,
        startDate: exp.startDate.toISOString().split('T')[0],
        endDate: exp.endDate ? exp.endDate.toISOString().split('T')[0] : '',
        current: exp.current,
        description: exp.description,
        skills: exp.skills,
        achievements: exp.achievements.join('\n') // Chuy·ªÉn m·∫£ng th√†nh chu·ªói ph√¢n t√°ch b·∫±ng d√≤ng m·ªõi
      })),
      projects: completeProfile!.projects.map(proj => ({
        id: proj.id,
        title: proj.title,
        description: proj.description,
        technologies: proj.technologies,
        startDate: proj.startDate.toISOString().split('T')[0],
        endDate: proj.endDate ? proj.endDate.toISOString().split('T')[0] : '',
        current: proj.current,
        githubUrl: proj.githubUrl,
        liveUrl: proj.liveUrl,
        imageUrl: proj.imageUrl
      })),
      languages: completeProfile!.languages.map(lang => ({
        id: lang.id,
        name: lang.name,
        proficiency: lang.proficiency,
        certification: lang.certification
      })),
      certifications: completeProfile!.certifications.map(cert => ({
        id: cert.id,
        name: cert.name,
        issuer: cert.issuer,
        issueDate: cert.issueDate.toISOString().split('T')[0],
        expiryDate: cert.expiryDate ? cert.expiryDate.toISOString().split('T')[0] : '',
        credentialId: cert.credentialId,
        credentialUrl: cert.credentialUrl
      })),
      // ƒê·∫£m b·∫£o tr·∫£ v·ªÅ gi√° tr·ªã profile_completion ƒë√£ c·∫≠p nh·∫≠t
      profile_completion: completeProfile!.profile_completion || 0,
      total_certifications: completeProfile!.certifications.length,
      total_projects: completeProfile!.projects.length
    };
    
    // Tr·∫£ v·ªÅ k·∫øt qu·∫£
    res.json({
      success: true,
      data: responseData
    });
  } catch (error) {
    console.error('Error updating profile:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Server error: ' + (error as Error).message 
    });
  }
});

// L·∫•y profile c·ªßa user hi·ªán t·∫°i
router.get('/profile', authenticateToken, async (req, res) => {
  try {
    const userId = (req as any).user?.id;
    
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: 'User not authenticated'
      });
    }

    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: {
        studentProfile: {
          include: {
            educations: true,
            workExperiences: true,
            projects: true,
            languages: true,
            certifications: true
          }
        }
      }
    });

    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'User not found'
      });
    }

    // Tr·∫£ v·ªÅ profile d·ª±a v√†o role c·ªßa user
    let profileData = null;
    if (user.role === 'STUDENT') {
      if (user.studentProfile) {
        // User ƒë√£ c√≥ profile
        profileData = {
          id: user.studentProfile.id,
          firstName: user.studentProfile.firstName,
          lastName: user.studentProfile.lastName,
          email: user.email,
          phone: user.studentProfile.phone,
          dateOfBirth: user.studentProfile.dateOfBirth,
          university: user.studentProfile.university,
          major: user.studentProfile.major,
          graduationYear: user.studentProfile.graduationYear,
          gpa: user.studentProfile.gpa,
          skills: user.studentProfile.skills || [],
          portfolio: user.studentProfile.portfolio,
          linkedin: user.studentProfile.linkedin,
          github: user.studentProfile.github,
          resume: user.studentProfile.resume,
          avatar: user.studentProfile.avatar,
          summary: user.studentProfile.experience,
          education: user.studentProfile.educations.map(edu => ({
            id: edu.id,
            institution: edu.institution,
            degree: edu.degree,
            fieldOfStudy: edu.fieldOfStudy,
            startDate: edu.startDate.toISOString().split('T')[0],
            endDate: edu.endDate ? edu.endDate.toISOString().split('T')[0] : '',
            current: edu.current,
            gpa: edu.gpa,
            achievements: edu.achievements
          })),
          workExperience: user.studentProfile.workExperiences.map(exp => ({
            id: exp.id,
            company: exp.company,
            position: exp.position,
            startDate: exp.startDate.toISOString().split('T')[0],
            endDate: exp.endDate ? exp.endDate.toISOString().split('T')[0] : '',
            current: exp.current,
            description: exp.description,
            skills: exp.skills,
            achievements: exp.achievements.join('\n') // Chuy·ªÉn m·∫£ng th√†nh chu·ªói ph√¢n t√°ch b·∫±ng d√≤ng m·ªõi
          })),
          projects: user.studentProfile.projects.map(proj => ({
            id: proj.id,
            title: proj.title,
            description: proj.description,
            technologies: proj.technologies,
            startDate: proj.startDate.toISOString().split('T')[0],
            endDate: proj.endDate ? proj.endDate.toISOString().split('T')[0] : '',
            current: proj.current,
            githubUrl: proj.githubUrl,
            liveUrl: proj.liveUrl,
            imageUrl: proj.imageUrl
          })),
          languages: user.studentProfile.languages.map(lang => ({
            id: lang.id,
            name: lang.name,
            proficiency: lang.proficiency,
            certification: lang.certification
          })),
          certifications: user.studentProfile.certifications.map(cert => ({
            id: cert.id,
            name: cert.name,
            issuer: cert.issuer,
            issueDate: cert.issueDate.toISOString().split('T')[0],
            expiryDate: cert.expiryDate ? cert.expiryDate.toISOString().split('T')[0] : '',
            credentialId: cert.credentialId,
            credentialUrl: cert.credentialUrl
          })),
          // Tr·∫£ v·ªÅ gi√° tr·ªã profile_completion
          profile_completion: user.studentProfile.profile_completion || 0,
          total_certifications: user.studentProfile.certifications.length,
          total_projects: user.studentProfile.projects.length,
        };
      } else {
        // T·∫°o profile m·∫∑c ƒë·ªãnh n·∫øu ch∆∞a c√≥
        console.log('üÜï Creating new student profile for user:', userId);
        const newProfile = await prisma.studentProfile.create({
          data: {
            userId,
            firstName: 'Sinh vi√™n',
            lastName: 'Demo',
            skills: ['React', 'TypeScript', 'Node.js'], // Skills m·∫∑c ƒë·ªãnh
            profile_completion: 0 // Gi√° tr·ªã profile_completion ban ƒë·∫ßu
          }
        });
        
        profileData = {
          id: newProfile.id,
          firstName: newProfile.firstName,
          lastName: newProfile.lastName,
          email: user.email,
          phone: newProfile.phone,
          dateOfBirth: newProfile.dateOfBirth,
          university: newProfile.university,
          major: newProfile.major,
          graduationYear: newProfile.graduationYear,
          gpa: newProfile.gpa,
          skills: newProfile.skills || [],
          portfolio: newProfile.portfolio,
          linkedin: newProfile.linkedin,
          github: newProfile.github,
          resume: newProfile.resume,
          avatar: newProfile.avatar,
          summary: newProfile.experience,
          education: [],
          workExperience: [],
          projects: [],
          languages: [],
          certifications: [],
          // Gi√° tr·ªã profile_completion ban ƒë·∫ßu
          profile_completion: 0,
          total_certifications: 0,
          total_projects: 0,
        };
      }
    }

    res.json({
      success: true,
      data: profileData
    });
  } catch (error) {
    console.error('Error fetching profile:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
});

// Route ƒë·ªÉ test API
router.post('/test-profile-update', authenticateToken, async (req, res) => {
  try {
    const userId = (req as any).user?.id;
    if (!userId) {
      return res.status(401).json({ success: false, message: 'User not authenticated' });
    }
    
    console.log('üß™ Test API called with data:', req.body);
    
    res.json({
      success: true,
      message: 'Test API called successfully',
      data: {
        receivedData: req.body,
        userId: userId,
        timestamp: new Date().toISOString()
      }
    });
  } catch (error) {
    console.error('Error in test API:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
}); 